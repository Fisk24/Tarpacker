import re
from lib import logger

class ManifestParser():
    def __init__(self, man):
        self.man      = man
        self.order    = []
        self.comments = []
        self.data     = {}
        # self.data data structure is as follows: self.data = {"COMMENTS":[[],[]....], sectionname:[item1, item2, item3...]}
        # this class is utilized by parsing an existing manifest file, then directly manipulating self.data.
        # optionally self.data can be used to overwrite an existing manifest, or to create a new one

    def __str__(self):
        return self.printManifest()

    def generateManifest(self, man=None):
        if man == None:
            man = self.man 
        # open the manifest file, then write every line to the file one at a time
        lines = self.assembleManifestLines()
        with open(man, "w") as manifest:
            for i in lines:
                manifest.write(i)

    def assembleManifestLines(self):
        lines = []
        # reassemble the file in the same order as it was in before we opened it. Using the self.order list
        # generated by parseManifest
        for key in self.order:
            lines.append("[{}]\n".format(key))
            # itterate through the items in the list that corrosponds to the current key
            for i in self.data[key]:
                lines.append(i+"\n")
            lines.append("\n")

        return lines

    def parseManifest(self):
        # open manifest file, and parse its data into a dictionary self.data
        currentKey = ""
        with open(self.man, 'r') as manifest:
            lines = manifest.readlines()
            for line in lines:
                if re.search(r"^\[", line):
                    # when the parser comes across a new section of the manifest
                    # make note of the possition of the section in self.order
                    # then update the currentKey to reflect the new section
                    self.order.append(self._genDataKey(line))
                    currentKey = self._genDataKey(line)
                elif re.search(r"(^\n)",line):
                    pass

                # if a comment is detected, it is placed into a special list with its original index number paired with it
                elif self.detectComment(line):
                    self.comments.append([lines.index(line), line.strip("\n")])

                else:
                    self.data[currentKey].append(line.strip("\n"))

    def info(self):
        logger.out("#==== Mainfest Info ====#")
        logger.out("| {0:21} |".format(self.man))
        logger.out("#=======================#")
        self.printManifest()

    def printManifest(self):
        for key in self.order:
            logger.out(key+":")
            for i in self.data[key]:
                logger.out("\t"+i)

        return " "

    def detectComment(self, line):
        # Checks to see if the first non-whitespace character is equal to the comment character #, 
        # then return True or False dependong on the result
        # a comment MUST be on its own line, and not at the end of a normal data entry
        strippedLine = line.strip()
        if strippedLine[0] == "#":
            return True
        else:
            return False

    def _genDataKey(self, line):
        # in the class method self.parseManifest, clean up string by removing brackets, 
        # then create a dictionary key using the clean string
        x = line
        for i in ["[", "]", "\n"]:
            x = x.replace(i, "")
            
        self.data[x] = []
        return x


